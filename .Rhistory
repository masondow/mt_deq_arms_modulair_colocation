geom_line(aes(y = nc_purpleair_cf1, color = "PurpleAir")) +
geom_hline(
yintercept = aqi_breaks,
color = aqi_colors,
linetype = "dashed"
) +
annotate("text", x = final_date + days(10), y = 12,     label = "Good",         vjust = -0.5, hjust = 1.1) +
annotate("text", x = final_date + days(10), y = 35.4,   label = "Moderate",     vjust = -0.5, hjust = 1.1) +
annotate("text", x = final_date + days(10), y = 55.4,   label = "USG",          vjust = -0.5, hjust = 1.1) +
annotate("text", x = final_date + days(10), y = 150.4,  label = "Unhealthy",    vjust = -0.5, hjust = 1.1) +
annotate("text", x = final_date + days(10), y = 250.4,  label = "V. Unhealthy", vjust = -0.5, hjust = 1.1) +
scale_color_manual(values = monitor_colors) +
labs(
title = "PM2.5 Time Series at NC Site",
x = "Date",
y = "PM2.5 (µg/m³)",
color = "Monitor Type"
) +
theme_minimal()
# LT Site
ggplot(lt_daily, aes(x = date)) +
geom_line(aes(y = lt_thermo, color = "Thermo")) +
geom_line(aes(y = lt_modulair_pm25, color = "Modulair")) +
geom_line(aes(y = lt_purpleair_cf1, color = "PurpleAir")) +
geom_hline(
yintercept = aqi_breaks,
color = aqi_colors,
linetype = "dashed"
) +
annotate("text", x = final_date + days(10), y = 12,     label = "Good",         vjust = -0.5, hjust = 1.1) +
annotate("text", x = final_date + days(10), y = 35.4,   label = "Moderate",     vjust = -0.5, hjust = 1.1) +
annotate("text", x = final_date + days(10), y = 55.4,   label = "USG",          vjust = -0.5, hjust = 1.1) +
annotate("text", x = final_date + days(10), y = 150.4,  label = "Unhealthy",    vjust = -0.5, hjust = 1.1) +
annotate("text", x = final_date + days(10), y = 250.4,  label = "V. Unhealthy", vjust = -0.5, hjust = 1.1) +
scale_color_manual(values = monitor_colors) +
labs(
title = "PM2.5 Time Series at LT Site",
x = "Date",
y = "PM2.5 (µg/m³)",
color = "Monitor Type"
) +
theme_minimal()
plot_rp <- plot_fit(rp_data, mod_col = "rp_modulair_pm25", fem_col = "rp_fem_avg", site_label = "RP")
print(plot_rp)
plot_nc <- plot_fit(nc_data, mod_col = "nc_modulair_pm25", fem_col = "nc_1020", site_label = "NC")
print(plot_nc)
plot_lt <- plot_fit(lt_data, mod_col = "lt_modulair_pm25", fem_col = "lt_thermo", site_label = "LT")
print(plot_lt)
# Create correlation matrix with all variables to be potentially included in modeling using combined dataset
# - fem_avg: FEM PM2.5 measurement (true value)
# - mod_pm25: Modulair PM2.5 measurement (raw)
# - mod_rh: Modulair relative humidity
# - mod_tempc: Modulair ambient temperature (°C)
model_vars <- combined_data %>%
select(fem_avg, mod_pm25, mod_rh, mod_tempc)
# Calculate and visualize the correlation matrix using ggpairs
ggpairs(model_vars,
lower = list(continuous = wrap("smooth", alpha = 0.3, size = 0.1)),
upper = list(continuous = wrap("cor", size = 4)),
diag = list(continuous = "barDiag")) +
labs(title = "Correlation Matrix of Candidate Modeling Variables")
# For Loop to calculate accuracy metrics functions for each site & overall
datasets <- list(rp = rp_data, nc = nc_data, lt = lt_data)
results <- list()
col_info <- list(
rp = list(fem = "rp_fem_avg", mod = "rp_modulair_pm25", fem_aqi = "rp_fem_aqi", mod_aqi = "rp_modulair_aqi"),
nc = list(fem = "nc_1020", mod = "nc_modulair_pm25", fem_aqi = "nc_fem_aqi", mod_aqi = "nc_modulair_aqi"),
lt = list(fem = "lt_thermo", mod = "lt_modulair_pm25", fem_aqi = "lt_fem_aqi", mod_aqi = "lt_modulair_aqi")
)
for (site in names(datasets)) {
results[[site]] <- calculate_all_metrics(
data = datasets[[site]],
fem_col = col_info[[site]]$fem,
mod_col = col_info[[site]]$mod,
fem_aqi_col = col_info[[site]]$fem_aqi,
mod_aqi_col = col_info[[site]]$mod_aqi
)
}
# bind tables, print results
overall_table <- bind_rows(lapply(names(results), function(site) {
results[[site]]$overall %>% mutate(site = site)
}))
overall_table <- overall_table %>% select(site, everything())
kable(overall_table, caption = "Overall Accuracy Metrics by Site (FEM vs. Modulair)")
for (site in names(results)) {
print(kable(results[[site]]$stratified, caption = paste("Accuracy Metrics by AQI Category -", site, "Site")))
}
# apply accuracy metrics functions to combined dataset
combined_metrics <- calculate_all_metrics(
data = combined_data,
fem_col = "fem_avg",
mod_col = "mod_pm25",
fem_aqi_col = "fem_aqi",
mod_aqi_col = "mod_aqi"
)
# Display the overall metrics for the combined dataset
print(combined_metrics$overall)
# Display the stratified accuracy metrics by AQI category for the combined dataset
kable(combined_metrics$stratified, caption = "Accuracy Metrics by AQI Category - Combined Data")
write.csv(combined_summaries)
View(combined_summaries)
write_csv(combined_summaries)
# Save All kable() Tables to Excel Files
# Define data folder
data_folder <- here("data")
# Create the folder if it doesn't exist
if (!dir.exists(data_folder)) {
dir.create(data_folder)
}
# Save each table individually
# 1. Summary of Observations and AQI Category Counts
write_xlsx(combined_summaries, file.path(data_folder, "summary_aqi_counts.xlsx"))
library(writexl)
library(writexl)
# Load necessary libraries
if (!require(writexl)) {
install.packages("writexl")
library(writexl)
}
# Load necessary libraries
if (!require(writexl)) {
install.packages("writexl")
library(writexl)
}
library(writexl)
library(writexl)
# Save All kable() Tables to Excel Files
library(writexl)
# Define data folder
data_folder <- here("data")
# Create the folder if it doesn't exist
if (!dir.exists(data_folder)) {
dir.create(data_folder)
}
# Save each table individually
# 1. Summary of Observations and AQI Category Counts
write_xlsx(combined_summaries, file.path(data_folder, "summary_aqi_counts.xlsx"))
# 2. Descriptive Statistics for RP
write_xlsx(rp_stats, file.path(data_folder, "rp_descriptive_stats.xlsx"))
# 3. Descriptive Statistics for NC
write_xlsx(nc_stats, file.path(data_folder, "nc_descriptive_stats.xlsx"))
# 4. Descriptive Statistics for LT
write_xlsx(lt_stats, file.path(data_folder, "lt_descriptive_stats.xlsx"))
# 5. Overall Accuracy Metrics
write_xlsx(overall_table, file.path(data_folder, "overall_accuracy_metrics.xlsx"))
# 6. Stratified Accuracy Metrics by AQI Category for RP, NC, LT
write_xlsx(results$rp$stratified, file.path(data_folder, "rp_stratified_accuracy_metrics.xlsx"))
write_xlsx(results$nc$stratified, file.path(data_folder, "nc_stratified_accuracy_metrics.xlsx"))
write_xlsx(results$lt$stratified, file.path(data_folder, "lt_stratified_accuracy_metrics.xlsx"))
# 7. Stratified Accuracy Metrics for Combined Data
write_xlsx(combined_metrics$stratified, file.path(data_folder, "combined_stratified_accuracy_metrics.xlsx"))
# Confirmation Message
cat("✅ All tables printed with kable() have been saved successfully to the data folder.\n")
library(tidyverse)
library(tidymodels)
library(readxl)
library(lubridate)
library(AirMonitor)
library(here)
library(purrr)
library(knitr)
library(patchwork)
library(GGally)
source(here("functions", "analysis_functions.R"))
theme_set(theme_minimal())
# For tidymodels, seed by date for reproducibility
set.seed(20250314)
# Save All kable() Tables to Excel Files for report
library(writexl)
# Define data folder
data_folder <- here("data")
# Save each table individually
# 1. All Model Performance Metrics
write_xlsx(all_modeling_metrics, file.path(data_folder, "all_modeling_metrics.xlsx"))
library(tidyverse)
library(tidymodels)
library(readxl)
library(lubridate)
library(AirMonitor)
library(here)
library(purrr)
library(knitr)
library(patchwork)
library(GGally)
source(here("functions", "analysis_functions.R"))
theme_set(theme_minimal())
# For tidymodels, seed by date for reproducibility
set.seed(20250314)
# Load data from data folder
lt_data <- read_excel("../data/LT_data.xlsx")
nc_data <- read_excel("../data/NC_data.xlsx")
rp_data <- read_excel("../data/RP_data.xlsx")
## Calculate 24 hr. Averages
# uses averaging_threshold and daily_averages functions from function file
# applies 75% (18 hr.) threshold to hourly values to calculate daily averages
# Apply the function to each dataset:
rp_daily <- daily_averages(rp_data)
nc_daily <- daily_averages(nc_data)
lt_daily <- daily_averages(lt_data)
# Hourly Data
# Add AQI categories using AirMonitor's aqiCategories() function.
rp_data <- rp_data %>%
mutate(rp_modulair_aqi = aqiCategories(rp_modulair_pm25, pollutant = "PM2.5", NAAQS = "PM2.5_2024"),
rp_purpleair_aqi = aqiCategories(rp_purpleair_cf1, pollutant = "PM2.5", NAAQS = "PM2.5_2024"),
rp_fem_aqi = aqiCategories(rp_fem_avg, pollutant = "PM2.5", NAAQS = "PM2.5_2024"))
nc_data <- nc_data %>%
mutate(nc_modulair_aqi = aqiCategories(nc_modulair_pm25, pollutant = "PM2.5", NAAQS = "PM2.5_2024"),
nc_purpleair_aqi = aqiCategories(nc_purpleair_cf1, pollutant = "PM2.5", NAAQS = "PM2.5_2024"),
nc_fem_aqi = aqiCategories(nc_1020, pollutant = "PM2.5", NAAQS = "PM2.5_2024"))
lt_data <- lt_data %>%
mutate(lt_modulair_aqi = aqiCategories(lt_modulair_pm25, pollutant = "PM2.5", NAAQS = "PM2.5_2024"),
lt_purpleair_aqi = aqiCategories(lt_purpleair_cf1, pollutant = "PM2.5", NAAQS = "PM2.5_2024"),
lt_fem_aqi = aqiCategories(lt_thermo, pollutant = "PM2.5", NAAQS = "PM2.5_2024"))
# Daily Data
# Add AQI categories using AirMonitor's aqiCategories() function.
rp_daily <- rp_daily %>%
mutate(rp_modulair_aqi = aqiCategories(rp_modulair_pm25, pollutant = "PM2.5", NAAQS = "PM2.5_2024"),
rp_purpleair_aqi = aqiCategories(rp_purpleair_cf1, pollutant = "PM2.5", NAAQS = "PM2.5_2024"),
rp_fem_aqi = aqiCategories(rp_fem_avg, pollutant = "PM2.5", NAAQS = "PM2.5_2024"))
nc_daily <- nc_daily %>%
mutate(nc_modulair_aqi = aqiCategories(nc_modulair_pm25, pollutant = "PM2.5", NAAQS = "PM2.5_2024"),
nc_purpleair_aqi = aqiCategories(nc_purpleair_cf1, pollutant = "PM2.5", NAAQS = "PM2.5_2024"),
nc_fem_aqi = aqiCategories(nc_1020, pollutant = "PM2.5", NAAQS = "PM2.5_2024"))
lt_daily <- lt_daily %>%
mutate(lt_modulair_aqi = aqiCategories(lt_modulair_pm25, pollutant = "PM2.5", NAAQS = "PM2.5_2024"),
lt_purpleair_aqi = aqiCategories(lt_purpleair_cf1, pollutant = "PM2.5", NAAQS = "PM2.5_2024"),
lt_fem_aqi = aqiCategories(lt_thermo, pollutant = "PM2.5", NAAQS = "PM2.5_2024"))
# Recode columns (& merge datasets, ignoring merge and using only RP dataset)
rp_modeling_data <- rp_data %>%
rename(fem_avg = rp_fem_avg,
mod_pm25 = rp_modulair_pm25,
fem_aqi = rp_fem_aqi,
mod_aqi = rp_modulair_aqi,
mod_rh = rp_modulair_rh,
mod_tempc = rp_modulair_tempc)
# #nc_combined <- nc_data %>%
#   rename(fem_avg = nc_1020,
#          mod_pm25 = nc_modulair_pm25,
#          fem_aqi = nc_fem_aqi,
#          mod_aqi = nc_modulair_aqi,
#          mod_rh = nc_modulair_rh)
#
# lt_combined <- lt_data %>%
#   rename(fem_avg = lt_thermo,
#          mod_pm25 = lt_modulair_pm25,
#          fem_aqi = lt_fem_aqi,
#          mod_aqi = lt_modulair_aqi,
#          mod_rh = lt_modulair_rh)
combined_modeling_data <- rp_modeling_data # only RP for now, other datasets not fit for model training/testing
data_split <- initial_split(combined_modeling_data, prop = 0.8)
training_data <- training(data_split)
testing_data  <- testing(data_split)
# Recipe using only modulair PM2.5 (base recipe)
base_linear_recipe <- recipe(fem_avg ~ mod_pm25, data = training_data)
# Recipe with additive RH term
linear_rh_recipe <- recipe(fem_avg ~ mod_pm25 + mod_rh, data = training_data)
# Recipe with modulair PM2.5, RH, and temperature
linear_temp_rh_recipe <- recipe(fem_avg ~ mod_pm25 + mod_rh + mod_tempc, data = training_data)
# Recipe with interaction between modulair PM2.5 and RH
interaction_recipe <- recipe(fem_avg ~ mod_pm25 + mod_rh, data = training_data) %>%
step_interact(terms = ~ mod_pm25:mod_rh)
# Recipe with full interactions among modulair PM2.5, RH, and temperature
full_interaction_recipe <- recipe(fem_avg ~ mod_pm25 + mod_rh + mod_tempc, data = training_data) %>%
step_interact(terms = ~ mod_pm25:mod_rh + mod_pm25:mod_tempc + mod_rh:mod_tempc)
# Recipe adding a second-degree (quadratic) term for modulair PM2.5
quad_recipe <- recipe(fem_avg ~ mod_pm25, data = training_data) %>%
step_poly(mod_pm25, degree = 2, options = list(raw = TRUE))
# Not necessary for more than single spec as all specifications are linear, but can keep in code for future use/customization for other potential non-linear pollutant modeling
# Base linear regression model (using only mod_pm25)
linear_spec <- linear_reg() %>%
set_engine("lm")
# Linear model with modulair PM2.5 and RH
linear_rh_spec <- linear_reg() %>%
set_engine("lm")
# Linear model with modulair PM2.5, RH, and temperature
linear_temp_rh_spec <- linear_reg() %>%
set_engine("lm")
# Model for interaction (will be paired with the interaction_recipe)
interaction_spec <- linear_reg() %>%
set_engine("lm")
# Quadratic model specification (to be used with quad_recipe)
quad_spec <- linear_reg() %>%
set_engine("lm")
# Workflow for base linear model
wf_linear <- workflow() %>%
add_model(linear_spec) %>%
add_recipe(base_linear_recipe)
# Workflow for "Linear + RH" model
wf_linear_rh <- workflow() %>%
add_model(linear_rh_spec) %>%
add_recipe(linear_rh_recipe)
# Workflow for "Linear + RH + Temperature" model
wf_linear_temp_rh <- workflow() %>%
add_model(linear_temp_rh_spec) %>%
add_recipe(linear_temp_rh_recipe)
# Workflow for interaction model (mod_pm25 and mod_rh interaction)
wf_interaction <- workflow() %>%
add_model(interaction_spec) %>%
add_recipe(interaction_recipe)
# Workflow for full interaction model
wf_full_interaction <- workflow() %>%
add_model(interaction_spec) %>%
add_recipe(full_interaction_recipe)
# Workflow for quadratic model
wf_quad <- workflow() %>%
add_model(quad_spec) %>%
add_recipe(quad_recipe)
# Define WF list:
wf_list <- list(
"Base Linear"           = wf_linear,
"Linear + RH"           = wf_linear_rh,
"Linear + RH + Temp"    = wf_linear_temp_rh,
"Interaction"           = wf_interaction,
"Full Interaction"      = wf_full_interaction,
"Quadratic"             = wf_quad
)
# Model Fitting, Predictions and Metrics by Workflow
# For Loop using fit_evaluate_wf function from function file
# Loops over the workflows to fit models, predict on the test set, and collect metrics.
modeling_results <- map2(wf_list, names(wf_list), ~ fit_evaluate_wf(.x, .y, training_data, testing_data))
# Combine performance metrics from all models into a single table
all_modeling_metrics <- map_dfr(modeling_results, "metrics")
# Append modeled predictions to the testing dataset
# Update the testing set with predictions from each model w/ new column for each model's prediction
# For each workflow, add a new column to the testing_data
testing_data_updated <- testing_data
for(model_name in names(wf_list)) {
# Fit the workflow on the training data first
fit_mod <- wf_list[[model_name]] %>% fit(data = training_data)
# Generate predictions and add as a new column named "pred_<model_name>"
col_name <- paste0("pred_", gsub(" ", "_", tolower(model_name)))
testing_data_updated <- append_predictions(fit_mod, testing_data_updated, col_name)
}
# Apply the EPA PurpleAir U.S. correction equation to the Modulair measurements, AQI
testing_data_updated <- testing_data_updated %>%
mutate(
pa_us_correction = 0.524 * mod_pm25 - 0.0862 * mod_rh + 5.75
)
# Define the names of the prediction columns in the updated testing data
prediction_cols <- c("pred_base_linear",
"pred_linear_+_rh",
"pred_linear_+_rh_+_temp",
"pred_interaction",
"pred_full_interaction",
"pred_quadratic",
"pa_us_correction")
# Define the corresponding predicted AQI column names
pred_aqi_cols <- paste0(prediction_cols, "_aqi")
# Build predicted AQI category columns for each prediction column
testing_data_updated <- testing_data_updated %>%
mutate(across(all_of(prediction_cols),
~ aqiCategories(.x, pollutant = "PM2.5", NAAQS = "PM2.5_2024"),
.names = "{.col}_aqi"))
# Comparison table of performance metrics (rounded + formatted)
all_modeling_metrics %>%
mutate(across(where(is.numeric), ~ round(.x, 2))) %>%
kable(caption = "Key Accuracy Metrics by Model (Testing Data")
# Generate residual plots for each prediction column
residual_plots <- map(prediction_cols, function(pred_col) {
testing_data_updated %>%
mutate(residual = fem_avg - .data[[pred_col]]) %>%
ggplot(aes(x = .data[[pred_col]], y = residual)) +
geom_point(alpha = 0.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(title = paste("Residual Plot for", pred_col),
x = paste("Predicted FEM PM2.5 (", pred_col, ")"),
y = "Residual (FEM - Predicted)") +
theme_minimal()
})
# Name each plot for easier reference
names(residual_plots) <- prediction_cols
# Print each residual plot
walk(residual_plots, print)
# Loop over each pair of prediction and predicted AQI columns and calculate metrics using your calculate_all_metrics function
metrics_by_model <- map2(prediction_cols, pred_aqi_cols, function(pred_col, pred_aqi_col) {
calculate_all_metrics(
data = testing_data_updated,
fem_col = "fem_avg",
mod_col = pred_col,
fem_aqi_col = "fem_aqi",
mod_aqi_col = pred_aqi_col
)
})
# Extract overall metrics into a single tibble and add a column for the model name
overall_metrics <- map_dfr(metrics_by_model, "overall") %>%
mutate(model = prediction_cols)
# Extract stratified (by FEM AQI category) metrics into a single tibble
stratified_metrics <- map2_dfr(metrics_by_model, prediction_cols, function(x, model_name) {
x$stratified %>% mutate(model = model_name)
})
# Print the overall performance metrics table
overall_metrics %>%
knitr::kable(caption = "Overall Performance Metrics by Model")
# Print the stratified performance metrics table
stratified_metrics %>%
knitr::kable(caption = "Performance Metrics Stratified by AQI Category and Model")
# Generate scatterplots of Modeled vs. Actual FEM Avg. w/ 1:1 line + line of best fit (Pearson)
# uses plot_model_fit function from function file
# Loop over each prediction column and generate the plot using testing_data_updated
plots_list <- lapply(prediction_cols, function(pred_col) {
plot_model_fit(test_data = testing_data_updated, pred_col = pred_col, fem_col = "fem_avg")
})
# Combine all plots in a grid
combined_model_fit_plots <- wrap_plots(plots_list, ncol = 2)
combined_model_fit_plots
# Fit the final "Linear + RH" model to the entire combined dataset
final_model <- wf_linear_rh %>%
fit(data = combined_modeling_data)
# Generate final predictions using the final model on the combined dataset
final_predictions <- final_model %>%
predict(new_data = combined_modeling_data)
# Combine the final predictions with the combined_modeling_data
# Rename the prediction column to "pred_linear_rh_final"
final_modeled_data <- combined_modeling_data %>%
bind_cols(final_predictions %>% rename(pred_linear_rh_final = .pred)) %>%
# Add a new column for the predicted AQI category based on the final predictions
mutate(pred_linear_rh_final_aqi = aqiCategories(pred_linear_rh_final, pollutant = "PM2.5", NAAQS = "PM2.5_2024"))
# Apply the EPA PurpleAir U.S. correction equation to the Modulair measurements
final_modeled_data <- final_modeled_data %>%
mutate(
pa_us_correction = 0.524 * mod_pm25 - 0.0862 * mod_rh + 5.75,
pa_corrected_mod_aqi = aqiCategories(pa_us_correction, pollutant = "PM2.5", NAAQS = "PM2.5_2024")
)
# View the first few rows of the final modeled data
head(final_modeled_data)
# Compute performance metrics for our Final Model (Linear + RH)
final_model_metrics <- calculate_all_metrics(
data = final_modeled_data,
fem_col = "fem_avg",
mod_col = "pred_linear_rh_final",
fem_aqi_col = "fem_aqi",
mod_aqi_col = "pred_linear_rh_final_aqi"
)
final_overall <- final_model_metrics$overall %>%
mutate(Model = "Final Modeled PM2.5 (Linear + RH)")
# Compute performance metrics for the Uncorrected Modulair PM2.5 data
uncorrected_metrics <- calculate_all_metrics(
data = final_modeled_data,
fem_col = "fem_avg",
mod_col = "mod_pm25",
fem_aqi_col = "fem_aqi",
mod_aqi_col = "mod_aqi"
)
uncorrected_overall <- uncorrected_metrics$overall %>%
mutate(Model = "Uncorrected Modulair PM2.5")
# Compute performance metrics for the PA US Correction applied to Modulair data
pa_us_metrics <- calculate_all_metrics(
data = final_modeled_data,
fem_col = "fem_avg",
mod_col = "pa_us_correction",
fem_aqi_col = "fem_aqi",
mod_aqi_col = "pa_corrected_mod_aqi"
)
pa_us_overall <- pa_us_metrics$overall %>%
mutate(Model = "EPA PA US Correction Applied")
# Combine all metrics into a single comparison table
comparison_table <- bind_rows(final_overall, uncorrected_overall, pa_us_overall) %>%
select(Model, R_squared, Average_Error, MAE, RMSE, NRMSE, Slope, Intercept, aqi_match_frequency)
# Display the final comparison table
comparison_table %>%
knitr::kable(caption = "Overall Performance Metrics Comparison: Final Model vs. Uncorrected Modulair vs. PA US Correction")
# Compute stratified performance metrics for the Final Model (Linear + RH)
final_stratified <- final_model_metrics$stratified %>%
mutate(Model = "Final Modeled PM2.5 (Linear + RH)")
# Compute stratified performance metrics for the Uncorrected Modulair PM2.5 data
uncorrected_stratified <- uncorrected_metrics$stratified %>%
mutate(Model = "Uncorrected Modulair PM2.5")
# Compute stratified performance metrics for the EPA PA US Correction applied to Modulair data
pa_us_stratified <- pa_us_metrics$stratified %>%
mutate(Model = "EPA PA US Correction Applied")
# Combine all stratified metrics into a single comparison table
stratified_comparison_table <- bind_rows(final_stratified, uncorrected_stratified, pa_us_stratified) %>%
select(Model, category, Count, R_squared, MAE, Average_Error, RMSE, NRMSE)
# Display the final stratified performance metrics comparison table
stratified_comparison_table %>%
knitr::kable(caption = "Stratified Final Modeling Performance Metrics Comparison by AQI Category")
# Extract the underlying model object using extract_fit_parsnip()
final_linear_rh_model_fit <- extract_fit_parsnip(final_model)$fit
# Get the coefficients from the linear model
linear_rh_model_coefs <- coef(final_linear_rh_model_fit)
print(linear_rh_model_coefs)
# Create readable equation using the correct coefficient names
model_equation <- paste0("Corrected PM2.5 = ",
round(linear_rh_model_coefs["(Intercept)"], 2), " + ",
round(linear_rh_model_coefs["mod_pm25"], 2), " * Modulair PM2.5 + ",
round(linear_rh_model_coefs["mod_rh"], 2), " * Modulair rh")
cat("Final Linear Model Equation:\n", model_equation, "\n")
# Save All kable() Tables to Excel Files for report
library(writexl)
# Define data folder
data_folder <- here("data")
# Save each table individually
# 1. All Model Performance Metrics
write_xlsx(all_modeling_metrics, file.path(data_folder, "all_modeling_metrics.xlsx"))
# 2. Overall Metrics for Each Model
write_xlsx(overall_metrics, file.path(data_folder, "overall_metrics_by_model.xlsx"))
# 3. Stratified Metrics by AQI Category for Each Model
write_xlsx(stratified_metrics, file.path(data_folder, "stratified_metrics_by_model.xlsx"))
# 4. Final Overall Model Comparison (Final vs Uncorrected vs EPA Correction)
write_xlsx(comparison_table, file.path(data_folder, "final_model_overall_comparison.xlsx"))
# 5. Final Stratified Model Comparison (Final vs Uncorrected vs EPA Correction)
write_xlsx(stratified_comparison_table, file.path(data_folder, "final_model_stratified_comparison.xlsx"))
# Confirmation Message
cat("✅ All tables from the modeling R Markdown document have been saved successfully to the data folder.\n")
Loop over each prediction column and generate the plot using testing_data_updated
# Loop over each prediction column and generate the plot using testing_data_updated
plots_list <- lapply(prediction_cols, function(pred_col) {
plot_model_fit(test_data = testing_data_updated, pred_col = pred_col, fem_col = "fem_avg")
})
# Combine all plots in a grid
combined_model_fit_plots <- wrap_plots(plots_list, ncol = 2)
combined_model_fit_plots
